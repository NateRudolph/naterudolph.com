<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Personal Portfolio of Nate Rudolph</title>
  
  <link rel="stylesheet" href="css/main.min.css">
  <link rel="shortcut icon" href="favicon.ico">
</head>

<body> <div class="header">
    <div class="header__video-link"></div>
    <h1 class="header__title title">I'm a designer & developer
        <br>of web, video, and things</h1>
</div>

<div class="single-page-content">
    <h1 class="single-page__title">FlexSensor Glove: Early Tests</h1>
    <h2>January 1, 0001</h2>
    

<p>{% include vimeoPlayer.html id=&ldquo;31157135&rdquo; %}</p>

<p>I’ve made some pretty significant steps in the FlexSensor Glove since the last post. The LED is now mounted to the finger tip, and the cords are soldered and wrapped neatly coming out of the glove to keep things from getting shorted or confusing when hooking up to the Arduino.</p>

<p>The code itself also has added the video element. My main goal was to be able to virtually click and drag things with the glove using the webcam as a point of entry. Instead of touching a track pad for instance, the user can bend their finger and two things happen. The LED lights up and tells the computer it is lit, and then starts drawing a purple circle at the coordinates of the LED. When the finger is unbent, the LED turns off and the computer quits tracking, in addition to leaving a darkened circle where it was last pointed to. (To clear up any confusion, here’s a video of it all happening.)</p>

<p>To make this usable for manipulating programs there needs to be an ‘off state’ that still tracks the hand. That way the user can move their hand and still see something, without actually manipulating any objects they’ve created. Then, there needs to be a way to check what the user has ‘clicked’ on, by checking the distance from their initial bent state and the existing object. If the distance is larger than the bounding box of the object, then the object’s coordinates shouldn’t be updated.</p>

<p>Once those elements are present, the actual video feed can change from a live webcam, to a user interface that is more conducive to manipulating graphic elements.</p>

<p>For those interested, I’ve included the source code used:</p>

<h2 id="processing">Processing:</h2>

<p>{% highlight java %}</p>

<p>/*
  nate rudolph
 CC Lab - 10/24/11
 */</p>

<p>/* Color Tracking sketch from:
 Learning Processing
 Daniel Shiffman
 <a href="http://www.learningprocessing.com">http://www.learningprocessing.com</a>
 Example 16-11: Simple color tracking
 */</p>

<p>import processing.video.<em>;
import processing.serial.</em>;</p>

<p>// Variable to open Serial communication with Arduino
Serial myPort;
float flexFloat;</p>

<p>// Variable to save the most recent ellipse
int lastX;
int lastY;</p>

<p>// Boolean to create the click and drag illusion
boolean isClickClose = true;
float distance;</p>

<p>// Variable for capture device
Capture video;</p>

<p>// A variable for the color we are searching for.
color trackColor;</p>

<p>void setup() {
  size(640, 480);
  video = new Capture(this, width, height, 30);
  // Start off tracking for purple light from LED
  trackColor = color(60, 0, 213);
  smooth();</p>

<p>myPort = new Serial(this, Serial.list()[0], 9600);
  myPort.bufferUntil(&rsquo;\n&rsquo;);
}</p>

<p>void serialEvent (Serial myPort) {
  String flexString = myPort.readStringUntil(&rsquo;\n&rsquo;);
  if (flexString != null) {
    flexString = trim(flexString);
    flexFloat = float(flexString);
    //println(flexFloat);
  }
}</p>

<p>void draw() {</p>

<p>//println(flexFloat);</p>

<p>// Capture and display the video
  if (video.available()) {
    video.read();
  }
  video.loadPixels();
  image(video, 0, 0);</p>

<p>// Before we begin searching, the &ldquo;world record&rdquo; for closest color is set to a high number that is easy for the first pixel to beat.
  float worldRecord = 500;</p>

<p>// XY coordinate of closest color
  int closestX = 0;
  int closestY = 0;</p>

<p>// Begin loop to walk through every pixel
  for (int x = 0; x &lt; video.width; x ++ ) {
    for (int y = 0; y &lt; video.height; y ++ ) {
      int loc = x + y*video.width;
      // What is current color
      color currentColor = video.pixels[loc];
      float r1 = red(currentColor);
      float g1 = green(currentColor);
      float b1 = blue(currentColor);
      float r2 = red(trackColor);
      float g2 = green(trackColor);
      float b2 = blue(trackColor);</p>

<pre><code>  // Using euclidean distance to compare colors
  float d = dist(r1, g1, b1, r2, g2, b2); // We are using the dist( ) function to compare the current color with the color we are tracking.

  // If current color is more similar to tracked color than
  // closest color, save current location and current difference
  if (d &lt; worldRecord) {
    worldRecord = d;
    closestX = x;
    closestY = y;
  }
}
</code></pre>

<p>}</p>

<p>// We only consider the color found if its color distance is less than 10.
  // This threshold of 10 is arbitrary and you can adjust this number depending on how accurate you require the tracking to be.
  if (worldRecord &lt; 15) {</p>

<pre><code>// check to see if initial click is close enough to old
if (isClickClose){

// Draw a circle at the tracked pixel (only when flex is active)
 if (flexFloat &lt; 70) {
  fill(trackColor);
  strokeWeight(10.0);
  stroke(0);
  ellipse(closestX, closestY, 50, 50);
}

lastX = closestX;
lastY = closestY;
</code></pre>

<p>}
  }</p>

<p>// Here the circle keeps getting drawn when the flex is not on</p>

<p>if (flexFloat &gt; 70) {
  pushMatrix();
  fill(trackColor-150);
  strokeWeight(5.0);
  stroke(0);
  ellipse(lastX, lastY, 45, 45);
  popMatrix();
  //isClickClose = false;
}</p>

<p>//float distance = dist(lastX,lastY,closestX,closestY);
//if (distance &lt; 30){
// isClickClose = true;
//}</p>

<p>}</p>

<p>// Original Sketch featured the option to click on a pixel
// and track that new color. Since I&rsquo;m using the same LED each time
// I commented this part out.
/*
void mousePressed() {
 // Save color where the mouse is clicked in trackColor variable
 int loc = mouseX + mouseY*video.width;
 trackColor = video.pixels[loc];
 }
 */</p>

<p>{% endhighlight %}</p>

<h2 id="arduino">Arduino</h2>

<p>{% highlight java %}
/*
  nate rudolph
 CC Lab - 10/14/11
/*</p>

<p>Huge thanks to the following website:
 <a href="http://arduinobasics.blogspot.com/2011/05/arduino-uno-flex-sensor-and-leds.html#comment-form">http://arduinobasics.blogspot.com/2011/05/arduino-uno-flex-sensor-and-leds.html#comment-form</a>
 It was one of the few sites that had tons of documentation for how to hook up a flex sensor.
 Including a lot of the code seen below.</p>

<p>Flex Sensor and LEDs created by ScottC on 23rd May 2011</p>

<p>*/</p>

<p>//Flex Sensor Pin (flexPin)
//the analog pin the Flex Sensor is connected to
int flexPin = 1;
const int LEDPin = 7;</p>

<p>boolean isFlexOn = false;</p>

<p>void setup() {
  Serial.begin(9600);
  pinMode(LEDPin, OUTPUT);
}</p>

<p>void loop(){</p>

<p>/* Read the flex Level
   Adjust the value 130 to 275 to span 4 to 13
   The values 130 and 275 may need to be widened to suit
   the minimum and maximum flex levels being read by the
   Analog pin */
  int flexLevel = map(analogRead(flexPin), 130, 275, 0, 100);</p>

<p>Serial.println(flexLevel);</p>

<p>//  digitalWrite(LEDPin, HIGH);</p>

<p>if (flexLevel &lt; 70){
    digitalWrite(LEDPin, HIGH);
    isFlexOn = true;
  }
  else {
    digitalWrite(LEDPin, LOW);
    isFlexOn = false;
  }
}</p>

<p>{% endhighlight %}</p>

    <p>
        <a href="https://naterudolph.com/">Home</a>
    </p>
</div>

<script src="https://naterudolph.com//js/all.js"></script>
</body>
</html>
